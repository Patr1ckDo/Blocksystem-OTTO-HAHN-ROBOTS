<head>
    <style>
        @font-face {
  font-family: octicons-link;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

body {
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
  color: #333;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
  width: 728px;
  max-width: 99%;
  box-sizing: border-box;
  padding: 30px 30px 8rem 30px;
  margin-left: auto;
  margin-right: auto;
}

body a {
  background-color: transparent;
}

body a:active,
body a:hover {
  outline: 0;
}

body strong {
  font-weight: bold;
}

body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

body img {
  border: 0;
}

body hr {
  box-sizing: content-box;
  height: 0;
}

body pre {
  overflow: auto;
}

body code,
body kbd,
body pre {
  font-family: monospace, monospace;
  font-size: 1em;
}

body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

body html input[disabled] {
  cursor: default;
}

body input {
  line-height: normal;
}

body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

body table {
  border-collapse: collapse;
  border-spacing: 0;
}

body td,
body th {
  padding: 0;
}

body * {
  box-sizing: border-box;
}

body input {
  font: 13px / 1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
}

body a {
  color: #4078c0;
  text-decoration: none;
}

body a:hover,
body a:active {
  text-decoration: underline;
}

body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

body hr:before {
  display: table;
  content: "";
}

body hr:after {
  display: table;
  clear: both;
  content: "";
}

body h1,
body h2,
body h3,
body h4,
body h5,
body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

body h1 {
  font-size: 30px;
}

body h2 {
  font-size: 21px;
}

body h3 {
  font-size: 16px;
}

body h4 {
  font-size: 14px;
}

body h5 {
  font-size: 12px;
}

body h6 {
  font-size: 11px;
}

body blockquote {
  margin: 0;
}

body ul,
body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

body ol ol,
body ul ol {
  list-style-type: lower-roman;
}

body ul ul ol,
body ul ol ol,
body ol ul ol,
body ol ol ol {
  list-style-type: lower-alpha;
}

body dd {
  margin-left: 0;
}

body code {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

body pre {
  margin-top: 0;
  margin-bottom: 0;
  font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

body .select::-ms-expand {
  opacity: 0;
}

body .octicon {
  font: normal normal normal 16px/1 octicons-link;
  display: inline-block;
  text-decoration: none;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

body .octicon-link:before {
  content: '\f05c';
}

body:before {
  display: table;
  content: "";
}

body:after {
  display: table;
  clear: both;
  content: "";
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

body .anchor {
  display: inline-block;
  padding-right: 2px;
  margin-left: -18px;
}

body .anchor:focus {
  outline: none;
}

body h1,
body h2,
body h3,
body h4,
body h5,
body h6 {
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

body h1 .octicon-link,
body h2 .octicon-link,
body h3 .octicon-link,
body h4 .octicon-link,
body h5 .octicon-link,
body h6 .octicon-link {
  color: #000;
  vertical-align: middle;
  visibility: hidden;
}

body h1:hover .anchor,
body h2:hover .anchor,
body h3:hover .anchor,
body h4:hover .anchor,
body h5:hover .anchor,
body h6:hover .anchor {
  text-decoration: none;
}

body h1:hover .anchor .octicon-link,
body h2:hover .anchor .octicon-link,
body h3:hover .anchor .octicon-link,
body h4:hover .anchor .octicon-link,
body h5:hover .anchor .octicon-link,
body h6:hover .anchor .octicon-link {
  visibility: visible;
}

body h1 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.2;
}

body h1 .anchor {
  line-height: 1;
}

body h2 {
  padding-bottom: 0.3em;
  font-size: 1.5em;
  line-height: 1.225;
}

body h2 .anchor {
  line-height: 1;
}

body h3 {
  font-size: 1.25em;
  line-height: 1.43;
}

body h3 .anchor {
  line-height: 1.2;
}

body h4 {
  font-size: 1em;
}

body h4 .anchor {
  line-height: 1.2;
}

body h5 {
  font-size: 1em;
}

body h5 .anchor {
  line-height: 1.1;
}

body h6 {
  font-size: 1em;
  color: #777;
}

body h6 .anchor {
  line-height: 1.1;
}

body p,
body blockquote,
body ul,
body ol,
body dl,
body table,
body pre {
  margin-top: 0;
  margin-bottom: 16px;
}

body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

body ul,
body ol {
  padding-left: 2em;
}

body ul ul,
body ul ol,
body ol ol,
body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

body li>p {
  margin-top: 16px;
}

body dl {
  padding: 0;
}

body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

body blockquote>:first-child {
  margin-top: 0;
}

body blockquote>:last-child {
  margin-bottom: 0;
}

body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

body table th {
  font-weight: bold;
}

body table th,
body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

body img {
  max-width: 100%;
  box-sizing: content-box;
  background-color: #fff;
}

body code {
  padding: 0;
  padding-top: 0;
  padding-bottom: 0;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

body code:before,
body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

body .highlight {
  margin-bottom: 16px;
}

body .highlight pre,
body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

body pre {
  word-wrap: normal;
}

body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

body pre code:before,
body pre code:after {
  content: normal;
}

body kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

body .pl-c {
  color: #969896;
}

body .pl-c1,
body .pl-s .pl-v {
  color: #0086b3;
}

body .pl-e,
body .pl-en {
  color: #795da3;
}

body .pl-s .pl-s1,
body .pl-smi {
  color: #333;
}

body .pl-ent {
  color: #63a35c;
}

body .pl-k {
  color: #a71d5d;
}

body .pl-pds,
body .pl-s,
body .pl-s .pl-pse .pl-s1,
body .pl-sr,
body .pl-sr .pl-cce,
body .pl-sr .pl-sra,
body .pl-sr .pl-sre {
  color: #183691;
}

body .pl-v {
  color: #ed6a43;
}

body .pl-id {
  color: #b52a1d;
}

body .pl-ii {
  background-color: #b52a1d;
  color: #f8f8f8;
}

body .pl-sr .pl-cce {
  color: #63a35c;
  font-weight: bold;
}

body .pl-ml {
  color: #693a17;
}

body .pl-mh,
body .pl-mh .pl-en,
body .pl-ms {
  color: #1d3e81;
  font-weight: bold;
}

body .pl-mq {
  color: #008080;
}

body .pl-mi {
  color: #333;
  font-style: italic;
}

body .pl-mb {
  color: #333;
  font-weight: bold;
}

body .pl-md {
  background-color: #ffecec;
  color: #bd2c00;
}

body .pl-mi1 {
  background-color: #eaffea;
  color: #55a532;
}

body .pl-mdr {
  color: #795da3;
  font-weight: bold;
}

body .pl-mo {
  color: #1d3e81;
}

body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

body .task-list-item {
  list-style-type: none;
}

body .task-list-item+.task-list-item {
  margin-top: 3px;
}

body .task-list-item input {
  margin: 0 0.35em 0.25em -1.6em;
  vertical-align: middle;
}

body :checked+.radio-label {
  z-index: 1;
  position: relative;
  border-color: #4078c0;
}
    </style>
</head>

<h1 id="-blocksystem-otto-hahn-robots-v1-0-0-"><strong>Blocksystem-OTTO-HAHN-ROBOTS</strong> <code>v1.0.0</code></h1>
<p><img src="Dokumentation/README-Bilder/Alle_Bloecke.png" alt="Alle Blöcke"></p>
<ul>
<li><a href="#einführung">Einführung</a><ul>
<li><a href="#installation">Installation</a></li>
</ul>
</li>
<li><a href="#blöcke">Blöcke</a><ul>
<li><a href="#start">Start</a></li>
<li><a href="#fahren">Fahren</a></li>
<li><a href="#drehen">Drehen</a></li>
<li><a href="#zurueckgelegtedistanz">ZurueckgelegteDistanz</a></li>
<li><a href="#cminumdrehungen">CminUmdrehungen</a></li>
<li><a href="#wartenaufdistanz">WartenAufDistanz</a></li>
<li><a href="#geschwindigkeitaendern">GeschwindigkeitAendern</a></li>
<li><a href="#ausrichtenlinie">AusrichtenLinie</a></li>
<li><a href="#linienverfolger">Linienverfolger</a></li>
</ul>
</li>
<li><a href="#beispielprogramme">Beispielprogramme</a></li>
<li><a href="#roboterprofile">Roboterprofile</a><ul>
<li><a href="#datensätze">Datensätze</a></li>
</ul>
</li>
<li><a href="#auswahlprogramm">Auswahlprogramm</a></li>
</ul>
<h2 id="einf-hrung">Einführung</h2>
<p>Dies ist das Blocksystem der OTTO-HAHN-ROBOTS zur Programmierung des EV3-Roboters für die First-Lego-League. Dieses Blocksystem fügt weitere (eigene) Blöcke zu EV3-Projekten hinzu, um die Programmierung zu erleichtern, den Zeitaufwand zu minimieren, die Genauigkeit des Roboters zu verbessern und um komplizierte Programmelememente für alle einfach nutzbar zu machen. Dabei sind diese Blöcke nicht komplett &quot;neu&quot;, sondern lediglich schon &quot;vorprogrammierte&quot; Programmelemente, die nun einfach genutzt werden können. In dieser Dokumentation ist alles Wichtige zu finden, was benötigt wird um die Blöcke nutzen zu können. </p>
<h3 id="installation">Installation</h3>
<p>Um die Blöcke in seinem Projekt nutzen zu können, müssen diese zuerst importiert werden. Dazu sollte als erstes der aktuelle Release des Blocksystems auf der Release-Seite auf GitHub heruntergeladen und entpackt werden. Anschließend wechselt man wieder zurückck auf die EV3-Software und öffnet den Tab &quot;Projekteigenschaften&quot;. Dort wechselt man auf den Tab &quot;Eigene Blöcke&quot; und drückt ganz unten auf &quot;Importieren&quot;. Daraufhin öffnet sich ein Datei-Browser, mit welchen man in sein eben entpacktes Verzeichnis hineinnavigiert und die Datei <code>Blocksystem_vX.X.X.ev3s</code>(anstelle der X wird dort die Nummer des aktuellen Releases stehen) öffnet. Anschließend drückt man auf öffnen und die Blöcke sind im EV3-Projekt vorhanden.</p>
<p> Sind die Blöcke installiert, lässt sich ganz einfach prüfen, welche Version momentan im EV3-Projekt importiert ist. Dazu öffnet man einfach den <a href="#start">Start-Block</a> und links neben dem Start-Symbol befindet sich eine Notiz, in welcher die Versionsnummer der momentan importierten Blocksystem-Version zu finden ist. Falls eine neuere Version vorhanden ist befolgt man die bereits oben beschriebenen erneut (nun mit der neuen Version, die wieder zuerst heruntergeladen werden muss). Bevor man die Blöcke jedoch importiert, müssen die Blöcke der alten Version zunächst gelöscht werden, dies ist auch direkt im Menü möglich wo man auch auf &quot;importieren&quot; drückt. Da beim installieren einer neueren Version des Blocksystems immerauch mal etwas falsch laufen kann, oder das Pogramm nach dem importieren der &quot;neuen&quot; Blöcke nicht mehr funktioniert, da an den Blöcken etwas geändert wurde, sollte umbedingt zunächst eine Sicherheitskopie des Programmes abgespeichert werden (dies ist zwischendurch sowieso empfehlenswert)!</p>
<h2 id="bl-cke">Blöcke</h2>
<p>Im Nachfolgenden werden die einzelnen Blöcke des Blocksystems mit ihren Funktionen und ihrer Benutzung, bzw. ihren Parametern, vorgesetellt!</p>
<h3 id="start">Start</h3>
<p><img src="Dokumentation/README-Bilder/Block_Start.png" alt="Start"></p>
<p>Dieser Block muss am Anfang jeden Programmes, in dem die Blöcke des Blocksystems genutzt werden, gesetzt werden, da hier alle Variablen, welche später benötigt werden, auf die entsprechenden Werte gesetzt werden. Dies geschieht aufgrund der angegebenen <a href="#roboterprofile">Roboter id</a>! Außerdem besteht die Möglichkeit einzustellen, dass sich der Roboter durch langsames fahren gegen die Bande am Anfang ausrichtet, was sich positiv auf die Genauigkeit beim Starten auswirkt. Anschließend werden alle Motoren zurückgesetzt.</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Wert</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td>Roboter id</td>
<td><a href="#roboterprofile">Roboter id</a></td>
<td>Durch die Roboter id wird der entsprechende Datensatz für einen Roboter gewählt, dieser wird dann in allen Blöcken des Blocksystems genutzt. Dazu muss der Datensatz eines Roboters im Blocksystem vorhanden sein. Eine Uebersicht dazu gibt es <a href="#roboterprofile">hier</a>!</td>
</tr>
<tr>
<td>Ausrichten</td>
<td>numerischer Wert (-1 - 1)</td>
<td>Um die Genauigkeit beim Starten zu erhöhen ist es empfehlenswert, dass der Roboter kurz vorwärts/rückwärts gegen die Wand / den Starter fährt. So ist sichergestellt, dass der Roboter komplett gerade steht. Mit <code>-1</code> fährt der Roboter kurz rückwärts, mit <code>1</code> kurz vorwärts. Bei <code>0</code> findet kein Ausrichten statt.</td>
</tr>
</tbody>
</table>
<h3 id="fahren">Fahren</h3>
<p><img src="Dokumentation/README-Bilder/Block_Fahren.png" alt="Fahren"></p>
<p> Der Fahren-Block ist nur für einfachere, nicht so komplexe Fahrten (wie sie mit dem Block <a href="#geschwindigkeitaendern">GeschwindigkeitAendern</a> möglich sind) geeignet, da dieser Block durchgängig nur in eine Richtung/gleichbleibender Kurvenradius fährt, und die Richtung nicht während der Fahrt geändert werden kann. Außerdem ist <strong>dieser Block nicht dafür ausgelegt auf der Stelle zu drehen</strong>. Dennoch verfügt der Fahren-Block über die Funktion langsam anzufahren und abzubremsen (<em>dies kann die Genauigkeit stark steigern</em>), wesshalb er für einfache Fahrten mit langsamen Anfahren/Abbremsen perfekt geeignet ist. <em>Sollten diese Funktion (langsam Anfahren/Abbremsen) nicht benötigt werden, ist es auch möglich den Block <a href="#cminumdrehungen">CmInUmdrehungen</a> in Kombination mit den Standard-EV3-Blöcken zu nutzen, da dieser Block / diese Blöcke wesentlich einfacher aufgebaut sind!</em> <strong>Auch dieser Block setzt die gefahren Umdrehungen nicht zurück, die Distanz wird am inneren Motor der Kurve gemessen!</strong></p>
<p> <img src="Dokumentation/README-Bilder/Block_Fahren_SkizzeDistanzen.png" alt="SkizzeDistanzen"></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Wert</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td>Richtung</td>
<td>numerischer Wert (-30 - 30)</td>
<td>Mit diesem Parameter wird festgelegt ob der Roboter gerade (<code>0</code>) fährt oder eine Kurve fahren soll. Gibt man hier einen negativen Wert an wird eine Linkskurve gefahren, d.h. der linke Motor dreht langsamer (egal ob der Roboter vorwärts oder rückwärts fährt), gibt man einen positiven Wert an genau andersrum.</td>
</tr>
<tr>
<td>CM Beschleunigung</td>
<td>numerischer Wert (0 - ∞)</td>
<td>Hier wird die Distanz angegeben, die der Roboter brauchen soll, bis er die gewünschte Geschwindigkeit erreicht hat.</td>
</tr>
<tr>
<td>Geschwindigkeit</td>
<td>numerischer Wert (-100 - 100)</td>
<td>Mit diesem Wert wird angegeben wie schnell der Roboter Fahren soll. Bei negativen Werten fährt der Roboter rückwärts, bei positiven vorwärts. <em>Es ist sinnvoll diese Geschwindigkeit nicht auf das Maximum oder auf das Minimum, wo der Roboter gerade so fährt, zu stellen, da diese Werte von Motor zu Motor stark variieren können, so dass der Roboter folglich sehr ungenau fahren kann.</em></td>
</tr>
<tr>
<td>CM Gesammt</td>
<td>numerischer Wert (&gt;0 -∞)</td>
<td>Dieser Parameter kontrolliert die Distanz, die während des kompletten Fahren-Blocks, inklusive Beschleunigungs- und Abbrems-Distanz, zurückgelegt werden soll. Daher muss dieser Parameter mindestens genauso groß sein wie Beschleunigungs- und Abbrems-Distanz zusammen.</td>
</tr>
<tr>
<td>CM Abbremsen</td>
<td>numerischer Wert (0 - ∞)</td>
<td>Hier wird die Distanz angegeben, die der Roboter brauchen soll, von der Fahrgeschwindigkeit bis zum Stehen abzubremsen.</td>
</tr>
</tbody>
</table>
<h3 id="drehen">Drehen</h3>
<p><img src="Dokumentation/README-Bilder/Block_Drehen.png" alt="Drehen"></p>
<p>Dieser Block ermöglicht es, dass sich der Roboter entweder auf der Stelle mit beiden Motoren, oder nur mit einem der Motoren dreht. Dabei ist es auch möglich, dass die Motoren langsam beschleunigen und auch langsam wieder abbremsen, <em>was die Genauigkeit erhöhen kann</em>. <strong>ACHTUNG: Im Gegensatz zu den meisten anderen Blöcken, setzt dieser Block die Motorumdrehungen am Anfang und am Ende zurück!!!</strong></p>
<p><img src="Dokumentation/README-Bilder/Block_Drehen_SkizzeWinkel.png" alt="SkizzeWinkel"></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Wert</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linker Motor</td>
<td>numerischer Wert (-1 - 1)</td>
<td>Mit diesem Parameter wird eingestellt in welche Richtung der Roboter, bzw. der linke Motor drehen soll: Gibt man hier <code>-1</code> an, dreht der Linke Motor rückwärts, bei <code>1</code> vorwärts und bei <code>0</code> bleibt er stehen.</td>
</tr>
<tr>
<td>Rechter Motor</td>
<td>numerischer Wert (-1 - 1)</td>
<td>Mit diesem Parameter wird, wie auch schon beim Parameter zuvor, die Richtung bestimmt, in die der rechte Motor drehen soll.</td>
</tr>
<tr>
<td>Grad Beschleunigen (Winkel)</td>
<td>numerischer Wert (0 - ∞)</td>
<td>Hier wird angegeben wie viel Grad der Roboter sich drehen soll bis er die gewünschte Geschwindigkeit erreicht hat. Wird hier <code>0</code> angegeben startet der Roboter sofort mit der angegebenen Geschwindigkeit und beschleunigt nicht langsam.</td>
</tr>
<tr>
<td>Geschwindigkeit</td>
<td>numerischer Wert (&gt;0 - 100)</td>
<td>Durch diesen Parameter wird kontrolliert wie schnell der Roboter sich drehen soll. Wenn sich nur einer der Motoren dreht, dreht der Roboter dementsprechend halb so schnell, als wenn sich beide Motoren drehen.</td>
</tr>
<tr>
<td>Grad Abbremsen (Winkel)</td>
<td>numerischer Wert (0 - ∞)</td>
<td>Wenn der Roboter langsam abbremsen soll, kann hier der Winkel angegeben werden, den es dauern soll bis der Roboter von der eingestellten Geschwindigkeit vollständig abgebremst hat. Wird hier <code>0</code> angegeben bremst der Roboter nicht langsam ab, sondern bleibt sofort stehen.</td>
</tr>
<tr>
<td>Winkel Drehen</td>
<td>numerischer Wert (&gt;0 - ∞)</td>
<td>Hier wird angegeben um wie viel Grad sich der Roboter insgesamt drehen soll. Dieser Winkel muss dabei mindest so groß sein wie der Winkel zur Beschleunigung und das Abbremsen zusammen.</td>
</tr>
</tbody>
</table>
<h3 id="zurueckgelegtedistanz">ZurueckgelegteDistanz</h3>
<p><img src="Dokumentation/README-Bilder/Block_ZurueckgelegteDistanz.png" alt="ZurueckgelgteDistanz"></p>
<p>Dieser Block gibt ähnlich wie der Standard-EV3-Block &quot;Motorumdrehung&quot; aus, wie weit sich ein Motor <strong>seit dem letzten zurücksetzten</strong> gedreht hat, im gegensatz zum Standard-EV3-Block gibt dieser Block jedoch die zurückgelegte Distanz in CM aus, was die Programmierung deutlich erleichtern kann. </p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Wert</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td>Motor</td>
<td>numerischer Wert (-1 / 1)</td>
<td>Wird hier <code>-1</code> angegben wird die zurückgelegte Distanz am linken (B) Motor gemessen. Falls hier <code>1</code> angegeben wird am rechten (C) Motor.</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Ausgabe</th>
<th>Wert</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td>Distanz in CM</td>
<td>numerischer Wert</td>
<td>Dieser Ausgabewert ist die zurückgelgte Distanz in CM. Falls der Motor seit dem letzten Zurücksetzen mehr rückwärts als vorwärts gedreht wurde, ist dieser Wert negativ (falls der Motor umgekehrt eingebaut wurde, wird dies mit berücksichtigt). Bei positiven Werten genau umgekehrt.</td>
</tr>
</tbody>
</table>
<h3 id="cminumdrehungen">CmInUmdrehungen</h3>
<p><img src="Dokumentation/README-Bilder/Block_CmInUmdrehungen.png" alt="CmInUmdrehungen"></p>
<p>Mit diesem Block ist es möglich eine Distanz von Zentimeter in Umdrehungen für den benutzen Roboter zu errechnen. Dies geschieht aufgrund der <a href="#roboterprofile">Roboter id</a>, welche am Start des Programmes als Parameter des <a href="#start">Start-Block</a> angegeben wird, bzw. aufgrund der hinterlegten Daten. So ist es mithilfe von diesem Block möglich auch mit Standard-EV3 Blöcken mit Cm-Angaben zu programmieren!</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Wert</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td>CM</td>
<td>numerischer Wert</td>
<td>Die Distanz in Cm die in Umdrehungen umgewandelt werden soll.</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Ausgabe</th>
<th>Wert</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td>Umdrehungen</td>
<td>numerischer Wert</td>
<td>Dieser Wert, der vom Block ausgegeben wird, ist die Anzahl der Umdrehungen, die aus der CM-Zahl errechnet wurde.</td>
</tr>
</tbody>
</table>
<h3 id="wartenaufdistanz">WartenAufDistanz</h3>
<p><img src="Dokumentation/README-Bilder/Block_WartenAufDistanz.png" alt="WartenAufDistanz"></p>
<p>Im Gegensatz zum Block <a href="#zurueckgelegtedistanz">ZurueckgelgteDistanz</a>, der nur die zureuckgelgte Distanz ausgibt, wartet dieser Block darauf das eine gewisse Distanz erreicht wird und hält das Programm so lange auf. Auch bei diesem Block wird die bis zum Start des Blockes zurückgelgte <strong>Distanz nicht zurückgesetzt</strong>, es gibt dennoch zwei verschiedene Modi. Bei einem der Modi wird die Distanz von Beginn des Blockes gemessen (simuliert das die Distanz am Anfang des Blockes zurückgesetz wird, wird sie jedoch in echt nicht), beim zweiten Modi wird die insgesammte Distanz, also seit dem letzten zurücksetzen berücksichtigt. <em>Mit Nutzung des zuletzt erklärten Modus, kann die Genauigkeit gesteigert werden, da so verherige ungenauigkeiten evtl. korrigiert werden können und sich die Fehler soo nicht immer weiter auf addieren!</em></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Wert</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td>Motor</td>
<td>numerischer Wert (-1 / 1)</td>
<td>Wird hier <code>-1</code> angegben wird die zurückgelegte Distanz am linken (B) Motor gemessen. Falls hier <code>1</code> angegeben wird am rechten (C) Motor.</td>
</tr>
<tr>
<td>Distanz in CM</td>
<td>numerischer Wert</td>
<td>Hier wir die Distanz (in CM) angegeben auf die der Block warten soll. Dabei kann die Zahl positiv oder negativ angegeben werden, jenachdem ob auf negative oder positive werde gewartet werden soll.</td>
</tr>
<tr>
<td>Von Beginn des Blocks</td>
<td>logischer Wert</td>
<td>Hier kann ausgewählt werden ab welchem der Punkt gemessen werden soll. Steht dieser Wert auf <code>Falsch</code> wird die Distanz seit dem letzen zurücksetzen der Motorumdrehungen berücksichtigt. Steht dieser Wert auf <code>Wahr</code> wird erst ab Beginn des Blocks gemessen, die Motorenumdrehungen werden aber <strong>nicht zurückgesetzt</strong>.</td>
</tr>
</tbody>
</table>
<h3 id="geschwindigkeitaendern">GeschwindigkeitAendern</h3>
<p><img src="Dokumentation/README-Bilder/Block_GeschwindigkeitAendern.png" alt="GeschwindigkeitAendern"></p>
<p>Mit diesem Block ist es möglich die Geschwindigkeiten der beiden Motoren (B und C) langsam zu verändern. Dabei können die Motoren auch unterschiedlich schnell laufen, jedoch <strong>nicht so, dass ein Motor vorwärts dreht und der andere ruckwärts</strong> (so würde sich der Roboter auf der Stelle drehen). <strong>Außerdem kann die Geschwindigkeit im Laufe der Beschleunigung nicht von einem positiven wert auf einen negativen Wert geändert werden.</strong> <em>Des Weiteren ist es Empfehlenswert die Geschwindigkeiten so hoch oder so niedrig zu wählen das die beiden Motoren starke abweichungen abweisen, was bei sehr geringen oder hohen Geschwindigkeiten der Fall ist.</em> Durch ein langsames ändern der Geschwindigkeit steigt die Genauigkeit!</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Wert</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td>Aktuelle Geschwindigkeit L</td>
<td>numerischer Wert (-100 - 100)</td>
<td>Hier wird die aktuelle Geschwindigkeit, bzw. die Geschwindigkeit, ab der die Beschleunigung beginnen soll für den linken (B) Motor angegeben. <strong>ACHTUNG: Der Wert muss so hoch sein, dass der Roboter sich vorwärts bewegt (also auf keinen Fall <code>0</code>).</strong> </td>
</tr>
<tr>
<td>Aktuelle Geschwindigkeit R</td>
<td>numerischer Wert (-100 - 100)</td>
<td>Der gleiche Parameter wie der zuvor erklärte Parameter Aktuelle Geschwindigkeit L, nur für den rechten (C) Motor.</td>
</tr>
<tr>
<td>CM</td>
<td>numerischer Wert (&gt;0 - ∞)</td>
<td>Dieser Parameter ist für die Strecke, die für die Beschleunigung / das Abbremsen gebraucht wird verantwortlich. Gemessen wird die Distanz vom Start des Blockes / der Geschwindigkeitsveränderung bis zum Ende des Blockes / der Geschwindigkeitsveränderung am Motor, welcher in dieser Zeit weniger Strecke zurücklegt (der Motor, der bei einer Kurve innen ist). <strong>Die Motorumdrehungen werden dabei nicht zurückgesetzt.</strong></td>
</tr>
<tr>
<td>Neue Geschwindigkeit L</td>
<td>numerischer Wert (-100 - 100)</td>
<td>Hier wird die Geschwindigkeit angegeben, die nach der Beschleunigen / dem Abbremsen, nach der zuvor angegebenen Distanz mit dem linken (B) Motor erreicht sein soll. <strong>ACHTUNG: Auch hier muss der Wert so hoch sein, dass der Roboter sich noch immer vorwärts bewegt (also auf keinen Fall <code>0</code>).</strong> </td>
</tr>
<tr>
<td>Neue Geschwindigkeit R</td>
<td>numerischer Wert (-100 -100)</td>
<td>Der gleiche Parameter wie der zuvor erklärte Parameter Neue Geschwindigkeit L, nur für den rechten (C) Motor.</td>
</tr>
</tbody>
</table>
<h3 id="ausrichtenlinie">AusrichtenLinie</h3>
<p><em>Noch nicht hinzugefügt!</em></p>
<h3 id="linienverfolger">Linienverfolger</h3>
<p><em>Noch nicht hinzugefügt!</em></p>
<h2 id="beispielprogramme">Beispielprogramme</h2>
<p><em>Beispielprogramme noch nicht hinzugefügt!</em></p>
<h2 id="roboterprofile">Roboterprofile</h2>
<table>
<thead>
<tr>
<th>Roboter id</th>
<th>Roboter / Nutzen</th>
<th>Status</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Rot-Schwarzer-Roboter (Gustav)</td>
<td>In Benutzung!</td>
</tr>
<tr>
<td>99</td>
<td>Nur zum Entwickeln und Testen der Blöcke, <strong>nicht Nutzen!</strong></td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="datens-tze">Datensätze</h3>
<p>Damit das Blocksystem mit möglichst allen Robotern funktioniert ist das komplette System variabel programmiert, so müssen nur bestimmte Variablen angepasst werden und das Blocksystem funktioniert mit jedem Roboter. Hinter jedem Roboter, welcher zunächst über den &quot;Roboter id&quot;-Parameter des Start Blockes ausgewählt wird, steckt ein Datensatz welcher bestimmte Eigenschaften, bzw. Parameter für diesen Roboter festlegt. Soll ein neuer Roboter in das Blocksystem eingepflegt werden, müssen zunächst alle untenstehenden Parameter festgelegt werden und diese dann unter einer neuen Roboter id in den Start Block des Blocksystem eingefügt werden.</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Wert</th>
<th>Beschreibung</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alle_MotorenrichtungUmgekehrt</td>
<td>logischer Wert</td>
<td>Falls die Motoren umgekehrt eingebaut wurden, d.h. der Roboter rückwärts fährt wenn die Motoren vorwärts drehen, muss dieser Wert auf <code>Wahr</code> gesetzt werden.</td>
</tr>
<tr>
<td><a href="#start">Start</a>_AusrichtenGeschwindigkeit</td>
<td>numerischer Wert (&gt;0 - 100)</td>
<td>Falls beim Start Block Ausrichten ausgewählt wird, fährt der Roboter langsam vorwärts, bzw. rückwärts um sich an der Wand auszurichten, so dass die Genauigkeit besser ist. Genau diese Geschwindigkeit wird durch diese Variable definiert.</td>
</tr>
<tr>
<td><a href="#start">Start</a>_AusrichtenSekunden</td>
<td>numerischer Wert (&gt;0 - ∞)</td>
<td>Falls das Ausrichten beim Start Block, wie zuvor erklärt, ausgewählt wird, findet das Ausrichten für eine gewisse Anzahl von Sekunden statt, diese Dauer wird hier definiert.</td>
</tr>
<tr>
<td><a href="#start">Start</a>_AusrichtenSekundenWarten</td>
<td>numerischer Wert (0 - ∞)</td>
<td>Nach dem zuvor erklärten Ausrichten wartet der Roboter eine gewisse Dauer damit die Motoren nicht direkt in die andere Richtung drehen (dies trägt zur Genauigkeit bei). Diese Dauer wird mit dieser Variable definiert.</td>
</tr>
<tr>
<td><a href="#zurueckgelegtedistanz">ZurueckgelegteDistanz</a>_CmInGrad</td>
<td>numerischer Wert (&gt;0 - ∞)</td>
<td>Da das Blocksystem wegen der intuitiveren Benutzung mit Distanzen in CM arbeitet wird hier definiert, wie viel Grad ein Motor drehen muss, damit der Roboter einen Zentimeter zurückgelegt hat.</td>
</tr>
<tr>
<td><a href="#fahren">Fahren</a>_StartGeschwindigkeit</td>
<td>numerischer Wert (&gt;0 - 100)</td>
<td>Wenn der Roboter mithilfe des Blocks <a href="#fahren">Fahren</a> langsam anfahren soll, beginnen sich die Motoren anfangs mit dem hier angegeben Wert. Daher sollte dieser Wert so groß gewählt werden, dass beide Motoren sich zuverlässig und gleichmäßig drehen, aber auch nicht zu schnell, damit der Roboter noch möglichst lange beschleunigen kann.</td>
</tr>
<tr>
<td><a href="#fahren">Fahren</a>_AbbremsenProzentEndgeschwindigkeit</td>
<td>numerischer Wert (0 - 100)</td>
<td>Wenn der Roboter mithilfe des Fahren-Blocks am Ende langsam abbremst wird das letzte Stück, nachdem der Roboter langsam abgebremst hat, konstant mit einer langsamen Geschwindigkeit absolviert bis die gewünschte Distanz entgültig erreicht wird. Dies trägt zur Genauigkeit bei, ohne dieses langsame Fahren am Ende ist ein genaues Stoppen gar nicht möglich! Mit diesem Parameter wird festgelgt wie viel Prozent der Strecke der Abbrems-Distanz dafür verwendet wird, mit der Endgeschwindigkeit zu fahren.</td>
</tr>
<tr>
<td><a href="#fahren">Fahren</a>_AbbremsenMaxDistanz Endgeschwindigkeit</td>
<td>numerischer Wert (0 - ∞)</td>
<td>Mit diesem Parameter wird kontrolliert, was die maximale Distanz ist, die mit der zuvor erläutertern Endgeschwindigkeit gefahren wird. Sollte die prozentual errechnete Strecke, welche mit dem zuvor erklärten Parameter errechnet wird, größer sein als die hier angegebene Strecke, wird die prozentual errechnete Strecke nicht beachtet und die hier angegebene Strecke wird genutzt.</td>
</tr>
<tr>
<td><a href="#fahren">Fahren</a>_EndGeschwindigkeit</td>
<td>numerischer Wert (&gt;0 - 100)</td>
<td>Mit diesem Parameter wird die End-Geschwindigkeit gesteuert, die am Ende des Abbremsens genutzt wird (wie in den beiden Parameter zuvor erklärt). Diese Geschwindigkeit sollte daher möglichst gering gewählt werden, damit der Roboter möglichst präzise anhalten kann. Sie sollte aber keinesfalls so niedrig gewählt werden, dass die Motoren sehr ungenau oder ungleichmäßig drehen.</td>
</tr>
<tr>
<td><a href="#drehen">Drehen</a>_StartGeschwindigkeit</td>
<td>numerischer Wert (&gt;0 - 100)</td>
<td>Mit diesem Parameter wird eingestellt mit welcher Geschwindigkeit der Roboter beim <a href="#drehen">Drehen Block</a> anfahren soll. Der Wert sollte so gering wie möglich gewählt werden, damit das Anfahren möglichst genau ist, aber auch nicht so gering, dass die Motoren sehr ungenau oder ungleichmäßig drehen.</td>
</tr>
<tr>
<td><a href="#drehen">Drehen</a>_GradFür360Drehung</td>
<td>numerischer Wert (&gt;0 - ∞)</td>
<td>Hier wird angegeben wie viel Grad sich ein Motor drehen muss, bis sich der Roboter um 360 Grad gedreht hat, wenn sich beide Motoren gleichzeitig drehen.</td>
</tr>
<tr>
<td><a href="#drehen">Drehen</a>_AbbremsenProzentEndgeschwindigkeit</td>
<td>numerischer Wert (0 - 100)</td>
<td>Mit diesem Wert wird eingestellt wie viel Prozent der Strecke des Abbremsens mit der eingestellten Endgeschwindigkeit zurückgelegt werden soll.</td>
</tr>
<tr>
<td><a href="#drehen">Drehen</a>_MaxWinkelEndgeschwindigkeit</td>
<td>numerischer Wert (0 - ∞)</td>
<td>Hier wird angegeben wie viel Grad (Winkel) maximal mit der Endgeschwindigkeit zurückgelegt werden sollen. Ist der Winkel, der durch den zuvor angegebenen Prozentsatz errechnet wird größer als dieser Wert, wird dieser Wert genutzt.</td>
</tr>
<tr>
<td><a href="#drehen">Drehen</a>_Endgeschwindigkeit</td>
<td>numerischer Wert (&gt;0 - 100)</td>
<td>Mit diesem Parameter wird eingestellt mit welcher Geschwindigkeit der Motor/die Motoren am Ende des Abbremsens drehen, bis der richtige Winkel erreicht ist.</td>
</tr>
<tr>
<td><a href="#drehen">Drehen</a>_SchwelleMotorKorrektion</td>
<td>numerischer Wert (&gt;0 - ∞)</td>
<td>Drehen beim Drehen Block beide Motoren wird nur an einem der Motoren aktiv gemessen und der andere Motor läuft jeweils mit derselben Geschwindigkeit (in die andere Richtung) einfach mit. Da die Motoren jedoch leicht unterschiedlich drehen können kann es so zu Ungenauigkeiten kommen. Um diesem entgegenzuwirken werden auch die Motorumdrehungen des anderen Motors gemessen und mit denen des &quot;richtigen&quot; Motors verglichen. Sollten die Motorenstände um eine gewisse Gradzahl, die mit diesem Parameter eingestellt wird, unterschiedlich sein wird gegengesteuert.</td>
</tr>
<tr>
<td><a href="#drehen">Drehen</a>_GeschwindigkeitMotorKorrektion</td>
<td>numerischer Wert (0 - 100)</td>
<td>Sollte die in dem zuvor erläuterte Schwelle überschritten werden wird der entsprechende Motor um eine gewisse Geschwindigkeit verschnellert oder verlangsamt. Diese Geschwindigkeit kann hier eingestellt werden.</td>
</tr>
</tbody>
</table>
<h2 id="auswahlprogramm">Auswahlprogramm</h2>
<p><em>Das Auswahlprogramm wird erst zu einem späteren Zeitpunkt hinzugefügt werden!</em></p>
